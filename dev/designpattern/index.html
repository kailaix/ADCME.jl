<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Design Pattern · ADCME</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ADCME logo"/></a><div class="docs-package-name"><span class="docs-autofit">ADCME</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../tutorial/">Overview</a></li><li><a class="tocitem" href="../resources/">Video Lectures and Slides</a></li><li><a class="tocitem" href="../tu_whatis/">What is ADCME? Computational Graph, Automatic Differentiation &amp; TensorFlow</a></li><li><a class="tocitem" href="../tu_basic/">ADCME Basics: Tensor, Type, Operator, Session &amp; Kernel</a></li><li><a class="tocitem" href="../tu_optimization/">PDE Constrained Optimization</a></li><li><a class="tocitem" href="../tu_sparse/">Sparse Linear Algebra</a></li><li><a class="tocitem" href="../tu_fd/">Numerical Scheme in ADCME: Finite Difference Example</a></li><li><a class="tocitem" href="../tu_fem/">Numerical Scheme in ADCME: Finite Element Example</a></li><li><a class="tocitem" href="../tu_inv/">Inverse Modeling with ADCME</a></li><li><a class="tocitem" href="../tu_recipe/">Inverse Modeling Recipe</a></li><li><a class="tocitem" href="../tu_nn/">Combining Neural Networks with Numerical Schemes</a></li><li><a class="tocitem" href="../tu_implicit/">Advanced: Automatic Differentiation for Implicit Operators</a></li><li><a class="tocitem" href="../tu_customop/">Advanced: Custom Operators</a></li><li><a class="tocitem" href="../tu_debug/">Advanced: Debugging and Profiling</a></li><li><a class="tocitem" href="../exercise/">Exercise: Inverse Modeling with ADCME</a></li></ul></li><li><span class="tocitem">Resources</span><ul><li><a class="tocitem" href="../newton_raphson/">Newton Raphson</a></li><li><a class="tocitem" href="../parallel/">Parallel Computing</a></li><li><a class="tocitem" href="../optimizers/">Optimizers</a></li><li><a class="tocitem" href="../ode/">PDE/ODE Solvers</a></li><li><a class="tocitem" href="../global/">Shared Memory Across Kernels</a></li><li><a class="tocitem" href="../julia_customop/">Julia Custom Operators</a></li><li><a class="tocitem" href="../nn/">Neural Networks</a></li><li><a class="tocitem" href="../ot/">Optimal Transport</a></li><li><a class="tocitem" href="../resource_manager/">Resource Manager</a></li><li><a class="tocitem" href="../alphascheme/">Generalized α Scheme</a></li><li><a class="tocitem" href="../factorization/">Direct Methods for Sparse Matrices</a></li><li><a class="tocitem" href="../customopt/">Custom Optimizer</a></li><li><a class="tocitem" href="../options/">Global Options</a></li><li><a class="tocitem" href="../smt/">Managing Numerical Experiments with SMT</a></li><li><a class="tocitem" href="../mcmc/">Uncertainty Quantification of Neural Networks in Physics Informed Learning using MCMC</a></li><li><a class="tocitem" href="../mpi/">Distributed Scientific Machine Learning using MPI</a></li></ul></li><li><span class="tocitem">Physics Informed Machine Learning</span><ul><li><a class="tocitem" href="../fdtd/">Finite-difference Time-domain for Electromagnetics and Seismic Inversion</a></li></ul></li><li><span class="tocitem">Deep Learning Schemes</span><ul><li><a class="tocitem" href="../vae/">Variational Autoencoder</a></li><li><a class="tocitem" href="../flow/">Normalizing Flows</a></li><li><a class="tocitem" href="../convnet/">Convolutional Neural Network</a></li><li><a class="tocitem" href="../bnn/">Bayesian Neural Networks</a></li></ul></li><li><span class="tocitem">Developer Guide</span><ul><li class="is-active"><a class="tocitem" href>Design Pattern</a><ul class="internal"><li><a class="tocitem" href="#Strategy-Pattern"><span>Strategy Pattern</span></a></li><li><a class="tocitem" href="#Adaptor-Pattern"><span>Adaptor Pattern</span></a></li><li><a class="tocitem" href="#Observer-Pattern"><span>Observer Pattern</span></a></li><li><a class="tocitem" href="#Decorator-Pattern"><span>Decorator Pattern</span></a></li><li><a class="tocitem" href="#Iterator-Pattern"><span>Iterator Pattern</span></a></li><li><a class="tocitem" href="#Factory-Pattern"><span>Factory Pattern</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li></ul></li><li><span class="tocitem">Applications</span><ul><li><a class="tocitem" href="../apps/">Overview</a></li><li><a class="tocitem" href="../apps_ana/">Adversarial Numerical Analysis</a></li><li><a class="tocitem" href="../apps_levy/">Calibrating Multivariate Lévy Processes with Neural Networks</a></li><li><a class="tocitem" href="../apps_constitutive_law/">Learning Constitutive Relations from Indirect Observations Using Deep Neural Networks</a></li><li><a class="tocitem" href="../apps_ad/">Intelligent Automatic Differentiation</a></li><li><a class="tocitem" href="../apps_adseismic/">General Seismic Inversion using Automatic Differentiation</a></li><li><a class="tocitem" href="../apps_nnfem/">Symmetric Positive Definite Neural Networks (SPD-NN)</a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer Guide</a></li><li class="is-active"><a href>Design Pattern</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Design Pattern</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kailaix/ADCME.jl/blob/master/docs/src/designpattern.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Design-Pattern"><a class="docs-heading-anchor" href="#Design-Pattern">Design Pattern</a><a id="Design-Pattern-1"></a><a class="docs-heading-anchor-permalink" href="#Design-Pattern" title="Permalink"></a></h1><p>Design patterns aim at providing reusable solutions for solving the challenges in the process of software development. The ultimate goal of design patterns is to avoid reinventing the wheels and making software flexible and resilient to change. Design patterns are neither concrete algorithms, nor programming templates, but ways of thinking. They are not always necessary if you can come up with very simple designs, which are actually more preferable in practice. Rather, they are &quot;rules of thumb&quot; that facilitates you when you have a hard time how to design the structure of your codes. </p><p>We strive to make ADCME easily maintainable and extendable by using well-established design patterns for some design decisions. In this section, we describe some design patterns that are useful for programming ADCME. </p><h2 id="Strategy-Pattern"><a class="docs-heading-anchor" href="#Strategy-Pattern">Strategy Pattern</a><a id="Strategy-Pattern-1"></a><a class="docs-heading-anchor-permalink" href="#Strategy-Pattern" title="Permalink"></a></h2><p>The strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. The strategy pattern makes programmers wrap algorithms that are subject to frequent changes (e.g., extending) as <strong>interfaces</strong> instead of concrete implementations. For example, in ADCME, <a href="@ref"><code>FlowOp</code></a> is implemented using the strategy pattern. </p><p>When you want to create a flow-based model, the structure <a href="@ref"><code>NormalizingFlow</code></a> has a method that performs a sequence of forward operations. The forward operations might have different combinations, which results in a large number of different normalizing flows. If we define a different normalizing flow structure for a different combination, there will be exponentially many such structures. Instead of defining a separate <code>forward</code> method for each different normalizing flow, we define an interface <a href="@ref"><code>FlowOp</code></a>, which has a <code>forward</code> method. </p><p>The interface is <strong>implemented</strong> with many concrete structures, which are called <strong>algorithms</strong> in the strategy pattern. These concrete <code>FlowOp</code>s, such as <code>SlowMAF</code> and <code>MAF</code>, have their specific <code>forward</code> implementations. Therefore, the system become easily extendable. When we have a new algorithm, we only need to add a new <code>FlowOp</code> instead of modifying <code>NormalizingFlow</code>. </p><h2 id="Adaptor-Pattern"><a class="docs-heading-anchor" href="#Adaptor-Pattern">Adaptor Pattern</a><a id="Adaptor-Pattern-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptor-Pattern" title="Permalink"></a></h2><p>The adapter pattern converts the interface of a structure into another interface users expect. It is very useful to unify the APIs and reuses the existing functions, and thus reliefs users from memorizing many new functions. The typical structure of an adaptor has the form</p><pre><code class="language-julia">struct Adaptor &lt;: AbstractNewComponent
    o::LegacyComponent
    function new_do_this(adaptor, x)
        old_do_this(adaptor.o, x)
    end
    ...
end </code></pre><p>Here users work with <code>AbstractNewComponent</code>, whose concrete types implement a function <code>new_do_this</code>. However, we have a structure of type <code>LegacyComponent</code>, which has a function <code>old_do_this</code>. An adaptor pattern is used to match an old function call <code>old_do_this</code> to <code>new_do_this</code> in the new system.</p><p>An example of adaptor pattern is <a href="../api/#ADCME.SparseTensor"><code>SparseTensor</code></a>, which wraps a <code>PyObject</code>. The operations on the <code>SparseTensor</code> is propagated to the <code>PyObject</code>, and therefore users can think in terms of the new <code>SparseTensor</code> data type. </p><h2 id="Observer-Pattern"><a class="docs-heading-anchor" href="#Observer-Pattern">Observer Pattern</a><a id="Observer-Pattern-1"></a><a class="docs-heading-anchor-permalink" href="#Observer-Pattern" title="Permalink"></a></h2><p>The observer pattern define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. The basic pattern is </p><p><strong>Subject</strong></p><pre><code class="language-julia">struct Subject
    o # Observer 
    state
    function update(s)
        # some operations on `s.state`
    end
    function notify(s)
        # some operations on `s.o`
    end
end</code></pre><p><strong>Observer</strong></p><pre><code class="language-julia">struct Observer
    subjects::Array{Subject}
    function update(o)
        for s in o.subjects
            update(s)
        end
    end
end</code></pre><p>For example, the <code>commitHistory</code> function in <a href="https://github.com/kailaix/NNFEM.jl">NNFEM.jl</a> uses the observer pattern to update states from <code>Domain</code>, to <code>Element</code>, and finally to <code>Material</code>. </p><h2 id="Decorator-Pattern"><a class="docs-heading-anchor" href="#Decorator-Pattern">Decorator Pattern</a><a id="Decorator-Pattern-1"></a><a class="docs-heading-anchor-permalink" href="#Decorator-Pattern" title="Permalink"></a></h2><p>The decorator pattern attaches additional responsibilities to an object dynamically. Decorator patterns are very similar to adaptor patterns. The difference is that the input and output types of the decorator pattern are the same. For example, if the input is a <code>SparseTensor</code>, the output should also be a <code>SparseTensor</code>. The adaptor pattern converts <code>PyObject</code> to <code>SparseTensor</code>. Another difference is that the decorator pattern usually does not change the methods and fields of the structure. For example,</p><pre><code class="language-julia">struct Juice
    cost::Float64 
end

function add_one_dollar(j::Juice)
    Juice(j.cost+1)
end</code></pre><p>Then <code>add_one_dollar(j)</code> is still a <code>Juice</code> structure but the cost is increased by 1. You can also compose multiple <code>add_one_dollar</code>:</p><pre><code class="language-julia">add_one_dollar(add_one_dollar(j))</code></pre><p>In Julia, this can be done elegantly using macros. We do not discuss macros in this section but leave it to another section on macros. </p><h2 id="Iterator-Pattern"><a class="docs-heading-anchor" href="#Iterator-Pattern">Iterator Pattern</a><a id="Iterator-Pattern-1"></a><a class="docs-heading-anchor-permalink" href="#Iterator-Pattern" title="Permalink"></a></h2><p>Iterator patterns provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation. Julia has built-in iterator support. The <code>in</code> keyword loops through iterations and <code>collect</code> collects all the entries in the iterator. In Julia, to understand iteration, remember that the following code</p><pre><code class="language-julia">for i in x
    # stuff
end</code></pre><p>is a shorthand for writing</p><pre><code class="language-julia">it = iterate(x)
while it !== nothing
    i, state = it
    # stuff
    it = iterate(x, state)
end</code></pre><p>Therefore, we only need to implement <code>iterate</code></p><pre><code class="language-julia">iterate(iter [, state]) -&gt; Union{Nothing, Tuple{Any, Any}}</code></pre><h2 id="Factory-Pattern"><a class="docs-heading-anchor" href="#Factory-Pattern">Factory Pattern</a><a id="Factory-Pattern-1"></a><a class="docs-heading-anchor-permalink" href="#Factory-Pattern" title="Permalink"></a></h2><p>The factory pattern defines an interface for creating an object, but lets subclasses decide which class to instantiate. Simply put, we define a function that returns a specific structure</p><pre><code class="language-julia">function factory(s::String)
    if s==&quot;StructA&quot;
        return StructA()
    elseif s==&quot;StructB&quot;
        return StructB()
    elseif s==&quot;StructC&quot;
        return StructC()
    else
        error(ArgumentError(&quot;$s is not understood&quot;))
    end
end</code></pre><p>For example, <code>FiniteStrainContinuum</code> in <code>NNFEM.jl</code> has a constructor</p><pre><code class="language-julia">function FiniteStrainContinuum(coords::Array{Float64}, elnodes::Array{Int64}, props::Dict{String, Any}, ngp::Int64=2)
    eledim = 2
    dhdx, weights, hs = get2DElemShapeData( coords, ngp )
    nGauss = length(weights)
    name = props[&quot;name&quot;]
    if name==&quot;PlaneStrain&quot;
        mat = [PlaneStrain(props) for i = 1:nGauss]
    elseif name==&quot;Scalar1D&quot;
        mat = [Scalar1D(props) for i = 1:nGauss]
    elseif name==&quot;PlaneStress&quot;
        mat = [PlaneStress(props) for i = 1:nGauss]
    elseif name==&quot;PlaneStressPlasticity&quot;
        mat = [PlaneStressPlasticity(props) for i = 1:nGauss]
    elseif name==&quot;PlaneStrainViscoelasticityProny&quot;
        mat = [PlaneStrainViscoelasticityProny(props) for i = 1:nGauss]
    elseif name==&quot;PlaneStressViscoelasticityProny&quot;
        mat = [PlaneStressViscoelasticityProny(props) for i = 1:nGauss]
    elseif name==&quot;PlaneStressIncompressibleRivlinSaunders&quot;
        mat = [PlaneStressIncompressibleRivlinSaunders(props) for i = 1:nGauss]
    elseif name==&quot;NeuralNetwork2D&quot;
        mat = [NeuralNetwork2D(props) for i = 1:nGauss]
    else
        error(&quot;Not implemented yet: $name&quot;)
    end
    strain = Array{Array{Float64}}(undef, length(weights))
    FiniteStrainContinuum(eledim, mat, elnodes, props, coords, dhdx, weights, hs, strain)
end</code></pre><p>Every time we add a new material, we need to modify this structure. This is not very desirable. Instead, we can have a function</p><pre><code class="language-julia">function get_element(s)
    if name==&quot;PlaneStrain&quot;
        PlaneStrain
    elseif name==&quot;Scalar1D&quot;
        Scalar1D
    ...
end</code></pre><p>This can also be achieved via Julia macros, thanks to the powerful meta-programming feature in ADCME. </p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>We have introduced some important design patterns that facilitate design maintainable and extendable software. Design patterns should not be viewed as rules to abide by, but they are useful principles in face of design difficulties. As mentioned, Julia provides powerful meta-programming features. These features can be used in the design patterns to simplify implementations. Meta-programming will be discussed in a future section.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bnn/">« Bayesian Neural Networks</a><a class="docs-footer-nextpage" href="../apps/">Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 14 August 2020 17:45">Friday 14 August 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
