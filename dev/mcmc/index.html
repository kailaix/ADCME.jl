<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Uncertainty Quantification of Neural Networks in Physics Informed Learning using MCMC · ADCME</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ADCME logo"/></a><div class="docs-package-name"><span class="docs-autofit">ADCME</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../tutorial/">Overview</a></li><li><a class="tocitem" href="../videos_and_slides/">Video Lectures and Slides</a></li><li><a class="tocitem" href="../tu_whatis/">What is ADCME? Computational Graph, Automatic Differentiation &amp; TensorFlow</a></li><li><a class="tocitem" href="../tu_basic/">ADCME Basics: Tensor, Type, Operator, Session &amp; Kernel</a></li><li><a class="tocitem" href="../tu_optimization/">PDE Constrained Optimization</a></li><li><a class="tocitem" href="../tu_sparse/">Sparse Linear Algebra</a></li><li><a class="tocitem" href="../tu_fd/">Numerical Scheme in ADCME: Finite Difference Example</a></li><li><a class="tocitem" href="../tu_fem/">Numerical Scheme in ADCME: Finite Element Example</a></li><li><a class="tocitem" href="../tu_inv/">Inverse Modeling with ADCME</a></li><li><a class="tocitem" href="../tu_recipe/">Inverse Modeling Recipe</a></li><li><a class="tocitem" href="../tu_nn/">Combining Neural Networks with Numerical Schemes</a></li><li><a class="tocitem" href="../tu_implicit/">Advanced: Automatic Differentiation for Implicit Operators</a></li><li><a class="tocitem" href="../tu_customop/">Advanced: Custom Operators</a></li><li><a class="tocitem" href="../tu_debug/">Advanced: Debugging and Profiling</a></li><li><a class="tocitem" href="../exercise/">Exercise: Inverse Modeling with ADCME</a></li></ul></li><li><span class="tocitem">Resources</span><ul><li><a class="tocitem" href="../newton_raphson/">Newton Raphson</a></li><li><a class="tocitem" href="../parallel/">Parallel Computing</a></li><li><a class="tocitem" href="../optimizers/">Optimizers</a></li><li><a class="tocitem" href="../optim/">Study on Optimizers</a></li><li><a class="tocitem" href="../ode/">PDE/ODE Solvers</a></li><li><a class="tocitem" href="../global/">Shared Memory Across Kernels</a></li><li><a class="tocitem" href="../julia_customop/">Julia Custom Operators</a></li><li><a class="tocitem" href="../nn/">Neural Networks</a></li><li><a class="tocitem" href="../ot/">Optimal Transport</a></li><li><a class="tocitem" href="../resource_manager/">Resource Manager</a></li><li><a class="tocitem" href="../alphascheme/">Generalized α Scheme</a></li><li><a class="tocitem" href="../factorization/">Direct Methods for Sparse Matrices</a></li><li><a class="tocitem" href="../customopt/">Custom Optimizer</a></li><li><a class="tocitem" href="../options/">Global Options</a></li><li class="is-active"><a class="tocitem" href>Uncertainty Quantification of Neural Networks in Physics Informed Learning using MCMC</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Forward-Computation"><span>Forward Computation</span></a></li><li class="toplevel"><a class="tocitem" href="#Inverse-Modeling"><span>Inverse Modeling</span></a></li><li class="toplevel"><a class="tocitem" href="#Uncertainty-Quantification"><span>Uncertainty Quantification</span></a></li></ul></li><li><a class="tocitem" href="../mpi/">Distributed Scientific Machine Learning using MPI</a></li><li><a class="tocitem" href="../mpi_benchmark/">MPI Benchmarks</a></li><li><a class="tocitem" href="../multithreading/">Understand the Multi-threading Model</a></li><li><a class="tocitem" href="../rbf/">Radial Basis Functions</a></li><li><a class="tocitem" href="../topopt/">Topological Optimization</a></li><li><a class="tocitem" href="../quadrature/">Numerical Integration</a></li></ul></li><li><span class="tocitem">Physics Informed Machine Learning</span><ul><li><a class="tocitem" href="../fdtd/">Finite-difference Time-domain for Electromagnetics and Seismic Inversion</a></li></ul></li><li><span class="tocitem">Deep Learning Schemes</span><ul><li><a class="tocitem" href="../vae/">Variational Autoencoder</a></li><li><a class="tocitem" href="../flow/">Normalizing Flows</a></li><li><a class="tocitem" href="../convnet/">Convolutional Neural Network</a></li><li><a class="tocitem" href="../bnn/">Bayesian Neural Networks</a></li></ul></li><li><span class="tocitem">Developer Guide</span><ul><li><a class="tocitem" href="../designpattern/">Design Pattern</a></li><li><a class="tocitem" href="../toolchain/">Built-in Toolchain for Third-party Libraries</a></li><li><a class="tocitem" href="../installmpi/">Configure MPI for Distributed Computing</a></li></ul></li><li><span class="tocitem">Applications</span><ul><li><a class="tocitem" href="../apps/">Overview</a></li><li><a class="tocitem" href="../apps_ana/">Adversarial Numerical Analysis</a></li><li><a class="tocitem" href="../apps_levy/">Calibrating Multivariate Lévy Processes with Neural Networks</a></li><li><a class="tocitem" href="../apps_constitutive_law/">Learning Constitutive Relations from Indirect Observations Using Deep Neural Networks</a></li><li><a class="tocitem" href="../apps_ad/">Intelligent Automatic Differentiation</a></li><li><a class="tocitem" href="../apps_adseismic/">General Seismic Inversion using Automatic Differentiation</a></li><li><a class="tocitem" href="../apps_nnfem/">Symmetric Positive Definite Neural Networks (SPD-NN)</a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Resources</a></li><li class="is-active"><a href>Uncertainty Quantification of Neural Networks in Physics Informed Learning using MCMC</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Uncertainty Quantification of Neural Networks in Physics Informed Learning using MCMC</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kailaix/ADCME.jl/blob/master/docs/src/mcmc.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Uncertainty-Quantification-of-Neural-Networks-in-Physics-Informed-Learning-using-MCMC"><a class="docs-heading-anchor" href="#Uncertainty-Quantification-of-Neural-Networks-in-Physics-Informed-Learning-using-MCMC">Uncertainty Quantification of Neural Networks in Physics Informed Learning using MCMC</a><a id="Uncertainty-Quantification-of-Neural-Networks-in-Physics-Informed-Learning-using-MCMC-1"></a><a class="docs-heading-anchor-permalink" href="#Uncertainty-Quantification-of-Neural-Networks-in-Physics-Informed-Learning-using-MCMC" title="Permalink"></a></h1><p>In this section, we consider uncertainty quantification of a neural network prediction using Markov Chain Monte Carlo. The idea is that we use MCMC to sample from the posterior distribution of the <strong>neural network weights and biases</strong>. We consider an inverse problem, where the governing equation is a heat equation in an 1D interval <span>$[0,1]$</span>.</p><p>The simulation is conducted over a time horizon <span>$[0,1]$</span>. We record the temperature <span>$u(0,t)$</span> on the left of the interval. The diffusivity coefficient <span>$\kappa(x)$</span> is assumed unknown and will be estimated from the temperature record. <span>$\kappa(x)$</span> is approximated by a neural network</p><p class="math-container">\[\kappa(x) = \mathcal{NN}_{w}(x)\]</p><p>Here <span>$w$</span> is the neural network weights and biases.</p><p>First of all, we define a function <code>simulate</code> that takes in the diffusivity coefficient, and returns the solution of the PDE.</p><p>File <code>heateq.jl</code>:</p><pre><code class="language-julia">using ADCME
using PyPlot
using ADCME
using PyCall
using ProgressMeter
using Statistics
using MAT
using DelimitedFiles
mpl = pyimport(&quot;tikzplotlib&quot;)

function simulate(κ)
    κ = constant(κ)
    m = 50
    n = 50
    dt = 1 / m
    dx = 1 / n
    F = zeros(m + 1, n)
    xi = LinRange(0, 1, n + 1)[1:end - 1]
    f = (x, t)-&gt;exp(-50(x - 0.5)^2)
    for k = 1:m + 1
        t = (k - 1) * dt
        F[k,:] = dt * f.(xi, t)
    end

    λ = κ*dt/dx^2
    mask = ones(n-1)
    mask[1] =  2.0
    A = spdiag(n, -1=&gt;-λ[2:end], 0=&gt;1+2λ, 1=&gt;-λ[1:end-1].*mask)


    function condition(i, u_arr)
        i &lt;= m + 1
    end

    function body(i, u_arr)
        u = read(u_arr, i - 1)
        rhs = u + F[i]
        u_next = A \ rhs
        u_arr = write(u_arr, i, u_next)
        i + 1, u_arr
    end

    F = constant(F)
    u_arr = TensorArray(m + 1)
    u_arr = write(u_arr, 1, zeros(n))
    i = constant(2, dtype = Int32)
    _, u = while_loop(condition, body, [i, u_arr])
    u = set_shape(stack(u), (m + 1, n))
end</code></pre><p>We set up the geometry as follows</p><pre><code class="language-julia">n = 50
xi = LinRange(0, 1, n + 1)[1:end - 1]
x = Array(LinRange(0, 1, n+1)[1:end-1])</code></pre><h1 id="Forward-Computation"><a class="docs-heading-anchor" href="#Forward-Computation">Forward Computation</a><a id="Forward-Computation-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-Computation" title="Permalink"></a></h1><p>The forward computation is run with an analytical <span>$\kappa(x)$</span>, given by <span>$\kappa(x) = 5x^2 + \exp(x) + 1.0$</span> We can generate the code using the following code:</p><pre><code class="language-julia">include(&quot;heateq.jl&quot;)

κ = @. 5x^2 + exp(x) + 1.0
out = simulate(κ)
obs = out[:,1]

sess = Session(); init(sess)
obs_ = run(sess, obs)

writedlm(&quot;obs.txt&quot;, run(sess, out))
o = run(sess, out)
pcolormesh( (0:49)*1/50, (0:50)*1/50, o, rasterized=true)
xlabel(&quot;\$x\$&quot;)
ylabel(&quot;\$t\$&quot;)
savefig(&quot;solution.png&quot;)

figure()
plot((0:50)*1/50, obs_)
xlabel(&quot;\$t\$&quot;)
ylabel(&quot;\$u(0,t)\$&quot;)
savefig(&quot;obs.png&quot;)

figure()
plot(x, κ)
xlabel(&quot;\$x\$&quot;)
ylabel(&quot;\$\\kappa\$&quot;)
savefig(&quot;kappa.png&quot;)</code></pre><table><tr><th style="text-align: right">Solution</th><th style="text-align: right">Observation</th><th style="text-align: right"><span>$\kappa(x)$</span></th></tr><tr><td style="text-align: right"><img src="https://github.com/ADCMEMarket/ADCMEImages/blob/master/ADCME/mcmc/./solution.png?raw=true" alt/></td><td style="text-align: right"><img src="https://github.com/ADCMEMarket/ADCMEImages/blob/master/ADCME/mcmc/./obs.png?raw=true" alt/></td><td style="text-align: right"><img src="https://github.com/ADCMEMarket/ADCMEImages/blob/master/ADCME/mcmc/./kappa.png?raw=true" alt/></td></tr></table><h1 id="Inverse-Modeling"><a class="docs-heading-anchor" href="#Inverse-Modeling">Inverse Modeling</a><a id="Inverse-Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Inverse-Modeling" title="Permalink"></a></h1><p>Although it is possible to use MCMC to solve the inverse problem, the convergence can be very slow if our initial guess is far away from the solution.</p><p>Therefore, we first solve the inverse problem by solving a PDE-constrained optimization problem. We use the <a href="../api/#ADCME.BFGS!"><code>BFGS!</code></a> optimizer. Note we do not need to solve the inverse problem very accurately because in Bayesian approaches, the solution is interpreted as a probability, instead of a point estimation.</p><pre><code class="language-julia">include(&quot;heateq.jl&quot;)
using PyCall
using Distributions
using Optim
using LineSearches
reset_default_graph()
using Random; Random.seed!(2333)
w = Variable(ae_init([1,20,20,20,1]), name=&quot;nn&quot;)
κ = fc(x, [20,20,20,1], w, activation=&quot;tanh&quot;) + 1.0
u = simulate(κ)
obs = readdlm(&quot;obs.txt&quot;)
loss = sum((u[:,1]-obs[:,1])^2)
loss = loss*1e10

sess = Session(); init(sess)


BFGS!(sess, loss)

κ1 = @. 5x^2 + exp(x) + 1.0
plot(x, run(sess, κ), &quot;+--&quot;, label=&quot;Estimation&quot;)
plot(x, κ1, label=&quot;Reference&quot;)
legend()
savefig(&quot;inversekappa.png&quot;)</code></pre><p><img src="https://github.com/ADCMEMarket/ADCMEImages/blob/master/ADCME/mcmc/./inversekappa.png?raw=true" alt/></p><p>We also save the solution for MCMC</p><pre><code class="language-julia">matwrite(&quot;nn.mat&quot;, Dict(&quot;w&quot;=&gt;run(sess, w)))</code></pre><h1 id="Uncertainty-Quantification"><a class="docs-heading-anchor" href="#Uncertainty-Quantification">Uncertainty Quantification</a><a id="Uncertainty-Quantification-1"></a><a class="docs-heading-anchor-permalink" href="#Uncertainty-Quantification" title="Permalink"></a></h1><p>Finally, we are ready to conduct uncertainty quantification using MCMC. We will use the <code>Mamba</code> package, which provides MCMC utilities. We will use the random walk MCMC because of its simplicity.</p><pre><code class="language-julia">include(&quot;heateq.jl&quot;)
using PyCall
using Mamba
using ProgressMeter
using PyPlot</code></pre><p>The neural network weights and biases are conveniently expressed as a <code>placeholder</code>. This allows us to <code>sample</code> from a distribution of weights and biases easily.</p><pre><code class="language-julia">w = placeholder(ae_init([1,20,20,20,1]))
κ = fc(x, [20,20,20,1], w, activation=&quot;tanh&quot;) + 1.0
u = simulate(κ)
obs = readdlm(&quot;obs.txt&quot;)

sess = Session(); init(sess)
w0 = matread(&quot;nn.mat&quot;)[&quot;w&quot;]</code></pre><p>The log likelihood function (up to an additive constant) is given by <span>$-{{{{\left\| {{u_{{\rm{est}}}}(w) - {u_{{\rm{obs}}}}} \right\|}^2}} \over {2{\sigma ^2}}} - {{{{\left\| w \right\|}^2}} \over {2\sigma _w^2}}$</span></p><p>The absolute value of <span>$\sigma$</span> and <span>$\sigma_w$</span> does not really matter. Only their ratios matter. Let&#39;s fix <span>$\sigma = 1$</span>. What is the interpretation of <span>$\sigma_w$</span>?</p><p>A large <span>$\sigma_w$</span> means very wide prior, and a small <span>$\sigma_w$</span> means a very narrow prior. The relative value <span>$\sigma/\sigma_w$</span> implies <strong>the strength of prior influence</strong>. Typically, we can choose a very large <span>$\sigma_w$</span> so that the prior does not influence the posterior too much. </p><pre><code class="language-julia">σ = 1.0
σx = 1000000.0
function logf(x)
    y = run(sess, u, w=&gt;x)
    -sum((y[:,1] - obs[:,1]).^2)/2σ^2 - sum(x.^2)/2σx^2
end

n = 5000
burnin = 1000
sim = Chains(n, length(w0))</code></pre><p>A second important parameter is the scale (0.002 in the following code). It controls <strong>the uncertainty bound width</strong> via the way we generate the random numbers.</p><pre><code class="language-julia">θ = RWMVariate(copy(w0), 0.001ones(length(w0)), logf, proposal = SymUniform)</code></pre><p>An immediate consequence is that the smaller the scale factor we use, the narrower the uncertainty band will be. In sum, we have two important parameters–relative standard deviation and the scaling factor–to control our uncertainty bound.</p><pre><code class="language-julia">
@showprogress for i = 1:n 
    sample!(θ)
    sim[i,:,1] = θ
end


v = sim.value
K = zeros(length(κ), n-burnin)
@showprogress for i = 1:n-burnin
    ws = v[i+burnin,:,1]
    K[:,i] = run(sess, κ, w=&gt;ws)
end 

kappa = mean(K, dims=2)[:]
k_std = std(K, dims=2)[:]
figure()
κ1 = @. 5x^2 + exp(x) + 1.0
PyPlot.plot(x, kappa, &quot;--&quot;, label=&quot;Posterior Mean&quot;)
PyPlot.plot(x, κ1, &quot;r&quot;, label=&quot;True&quot;)
PyPlot.plot(x, run(sess, κ, w=&gt;w0), label=&quot;Point Estimation&quot;)
fill_between(x, kappa-3k_std, kappa+3k_std, alpha=0.5)
legend()
xlabel(&quot;x&quot;)
ylabel(&quot;\$\\kappa(x)\$&quot;)
savefig(&quot;kappa_mcmc.png&quot;)</code></pre><p><img src="https://github.com/ADCMEMarket/ADCMEImages/blob/master/ADCME/mcmc/./kappa_mcmc.png?raw=true" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../options/">« Global Options</a><a class="docs-footer-nextpage" href="../mpi/">Distributed Scientific Machine Learning using MPI »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 7 January 2021 02:59">Thursday 7 January 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
