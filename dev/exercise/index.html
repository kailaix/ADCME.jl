<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Exercise: Inverse Modeling with ADCME · ADCME</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ADCME logo"/></a><div class="docs-package-name"><span class="docs-autofit">ADCME</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../tutorial/">Overview</a></li><li><a class="tocitem" href="../resources/">Video Lectures and Slides</a></li><li><a class="tocitem" href="../tu_whatis/">What is ADCME? Computational Graph, Automatic Differentiation &amp; TensorFlow</a></li><li><a class="tocitem" href="../tu_basic/">ADCME Basics: Tensor, Type, Operator, Session &amp; Kernel</a></li><li><a class="tocitem" href="../tu_optimization/">PDE Constrained Optimization</a></li><li><a class="tocitem" href="../tu_sparse/">Sparse Linear Algebra</a></li><li><a class="tocitem" href="../tu_fd/">Numerical Scheme in ADCME: Finite Difference Example</a></li><li><a class="tocitem" href="../tu_fem/">Numerical Scheme in ADCME: Finite Element Example</a></li><li><a class="tocitem" href="../tu_inv/">Inverse Modeling with ADCME</a></li><li><a class="tocitem" href="../tu_recipe/">Inverse Modeling Recipe</a></li><li><a class="tocitem" href="../tu_nn/">Combining Neural Networks with Numerical Schemes</a></li><li><a class="tocitem" href="../tu_implicit/">Advanced: Automatic Differentiation for Implicit Operators</a></li><li><a class="tocitem" href="../tu_customop/">Advanced: Custom Operators</a></li><li><a class="tocitem" href="../tu_debug/">Advanced: Debugging and Profiling</a></li><li class="is-active"><a class="tocitem" href>Exercise: Inverse Modeling with ADCME</a><ul class="internal"><li><a class="tocitem" href="#Background"><span>Background</span></a></li><li><a class="tocitem" href="#Problem-1:-Parameter-Inverse-Problem-in-1D"><span>Problem 1: Parameter Inverse Problem in 1D</span></a></li><li><a class="tocitem" href="#Problem-2:-Function-Inverse-Problem"><span>Problem 2: Function Inverse Problem</span></a></li><li><a class="tocitem" href="#Problem-3:-Parameter-Inverse-Problem-in-2D"><span>Problem 3: Parameter Inverse Problem in 2D</span></a></li></ul></li></ul></li><li><span class="tocitem">Resources</span><ul><li><a class="tocitem" href="../newton_raphson/">Newton Raphson</a></li><li><a class="tocitem" href="../parallel/">Parallel Computing</a></li><li><a class="tocitem" href="../optimizers/">Optimizers</a></li><li><a class="tocitem" href="../optim/">Study on Optimizers</a></li><li><a class="tocitem" href="../ode/">PDE/ODE Solvers</a></li><li><a class="tocitem" href="../global/">Shared Memory Across Kernels</a></li><li><a class="tocitem" href="../julia_customop/">Julia Custom Operators</a></li><li><a class="tocitem" href="../nn/">Neural Networks</a></li><li><a class="tocitem" href="../ot/">Optimal Transport</a></li><li><a class="tocitem" href="../resource_manager/">Resource Manager</a></li><li><a class="tocitem" href="../alphascheme/">Generalized α Scheme</a></li><li><a class="tocitem" href="../factorization/">Direct Methods for Sparse Matrices</a></li><li><a class="tocitem" href="../customopt/">Custom Optimizer</a></li><li><a class="tocitem" href="../options/">Global Options</a></li><li><a class="tocitem" href="../mcmc/">Uncertainty Quantification of Neural Networks in Physics Informed Learning using MCMC</a></li><li><a class="tocitem" href="../mpi/">Distributed Scientific Machine Learning using MPI</a></li><li><a class="tocitem" href="../mpi_benchmark/">MPI Benchmarks</a></li><li><a class="tocitem" href="../multithreading/">Understand the Multi-threading Model</a></li><li><a class="tocitem" href="../rbf/">Radial Basis Functions</a></li></ul></li><li><span class="tocitem">Physics Informed Machine Learning</span><ul><li><a class="tocitem" href="../fdtd/">Finite-difference Time-domain for Electromagnetics and Seismic Inversion</a></li></ul></li><li><span class="tocitem">Deep Learning Schemes</span><ul><li><a class="tocitem" href="../vae/">Variational Autoencoder</a></li><li><a class="tocitem" href="../flow/">Normalizing Flows</a></li><li><a class="tocitem" href="../convnet/">Convolutional Neural Network</a></li><li><a class="tocitem" href="../bnn/">Bayesian Neural Networks</a></li></ul></li><li><span class="tocitem">Developer Guide</span><ul><li><a class="tocitem" href="../designpattern/">Design Pattern</a></li><li><a class="tocitem" href="../toolchain/">Built-in Toolchain for Third-party Libraries</a></li><li><a class="tocitem" href="../installmpi/">Configure MPI for Distributed Computing</a></li></ul></li><li><span class="tocitem">Applications</span><ul><li><a class="tocitem" href="../apps/">Overview</a></li><li><a class="tocitem" href="../apps_ana/">Adversarial Numerical Analysis</a></li><li><a class="tocitem" href="../apps_levy/">Calibrating Multivariate Lévy Processes with Neural Networks</a></li><li><a class="tocitem" href="../apps_constitutive_law/">Learning Constitutive Relations from Indirect Observations Using Deep Neural Networks</a></li><li><a class="tocitem" href="../apps_ad/">Intelligent Automatic Differentiation</a></li><li><a class="tocitem" href="../apps_adseismic/">General Seismic Inversion using Automatic Differentiation</a></li><li><a class="tocitem" href="../apps_nnfem/">Symmetric Positive Definite Neural Networks (SPD-NN)</a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Exercise: Inverse Modeling with ADCME</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Exercise: Inverse Modeling with ADCME</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kailaix/ADCME.jl/blob/master/docs/src/exercise.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Exercise:-Inverse-Modeling-with-ADCME"><a class="docs-heading-anchor" href="#Exercise:-Inverse-Modeling-with-ADCME">Exercise: Inverse Modeling with ADCME</a><a id="Exercise:-Inverse-Modeling-with-ADCME-1"></a><a class="docs-heading-anchor-permalink" href="#Exercise:-Inverse-Modeling-with-ADCME" title="Permalink"></a></h1><p>The starter code can be downloaded <a href="https://github.com/kailaix/ADCME.jl/releases/download/ex_v1.0/Exercise.zip">here</a>.</p><h2 id="Background"><a class="docs-heading-anchor" href="#Background">Background</a><a id="Background-1"></a><a class="docs-heading-anchor-permalink" href="#Background" title="Permalink"></a></h2><p>The <strong>thermal diffusivity</strong> is the measure of the ease with which heat can diffuse through a material. Let <span>$u$</span> be the temperature, and <span>$\kappa$</span> be the thermal diffusivity. The heat transfer process is described by the Fourier law </p><div>\[\frac{\partial u(\mathbf{x}, t)}{\partial t} = \kappa\Delta u(\mathbf{x}, t) + f(\mathbf{x}, t), \quad t\in (0,T), x\in \Omega \tag{1}\]</div><p>Here <span>$f$</span> is the heat source and <span>$\Omega$</span> is the domain.</p><p>To make use of the heat equation, we need additional information. </p><ul><li><p><strong>Initial Condition</strong>: the initial temperature distribution is given by <span>$u(\mathbf{x}, 0) = u_0(\mathbf{x})$</span>. </p></li><li><p><strong>Boundary Conditions</strong>: the temperature of the material is affected by what happens on the boundary. There are several possible boundary conditions. In this exercise we consider two of them:</p><p>(1) Temperature fixed at a boundary,</p><div>\[u(\mathbf{x}, t) = 0, \quad \mathbf{x}\in \Gamma_D \tag{2}\]</div><p>(2) Insulated boundary. The heat flow can be prescribed (known as the <em>no flow</em> boundary condition)</p><div>\[-\kappa\frac{\partial u(\mathbf{x},t)}{\partial n} = 0, \quad \mathbf{x}\in \Gamma_N \tag{3}\]</div><p>Here <span>$n$</span> is the outward normal vector. </p><p>The boundaries <span>$\Gamma_D$</span> and <span>$\Gamma_N$</span> satisfy <span>$\partial \Omega = \Gamma_D \cup \Gamma_N, \Gamma_D\cap \Gamma_N = \emptyset$</span>.</p></li></ul><p>Assume that we want to experiment with a piece of new material. The thermal diffusivity coefficient of the material is an unknown function of the space. Our goal of the experiment is to find out the thermal diffusivity coefficient. To this end, we place some sensors in the domain or on the boundary. The measurements are sparse in the sense that only the temperature from those sensors–-but nowhere else–-are collected. Namely, let the sensors be located at <span>$\{\mathbf{x}_i\}_{i=1}^M$</span>, then we can observe <span>$\{\hat u(\mathbf{x}_i, t)\}_{i=1}^M$</span>, i.e., the measurements of <span>$\{ u(\mathbf{x}_i, t) \}_{i=1}^M$</span>. We also assume that the boundary conditions, initial conditions and the source terms are known. </p><p><img src="./assets/ex_figure.png" alt/> </p><h2 id="Problem-1:-Parameter-Inverse-Problem-in-1D"><a class="docs-heading-anchor" href="#Problem-1:-Parameter-Inverse-Problem-in-1D">Problem 1: Parameter Inverse Problem in 1D</a><a id="Problem-1:-Parameter-Inverse-Problem-in-1D-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-1:-Parameter-Inverse-Problem-in-1D" title="Permalink"></a></h2><p>We first consider the 1D case. In this problem, the material is a rod <span>$\Omega=[0,1]$</span>. We consider a homogeneous (zero) fixed boundary condition on the right side, and an insulated boundary on the left side. The initial temperature is zero everywhere, i.e., <span>$u(x, 0)=0$</span>, <span>$x\in [0,1]$</span>. The source term is <span>$f(x, t) = \exp(-10(x-0.5)^2)$</span>, and <span>$\kappa(x)$</span> is a function of space</p><div>\[\kappa(x) = a + bx\]</div><p>Our task is to estimate the coefficient <span>$a$</span> and <span>$b$</span> in <span>$\kappa(x)$</span>. To this end, we place a sensor at <span>$x=0,$</span> and the sensor records the temperature as a time series <span>$u_0(t)$</span>, <span>$t\in (0,1)$</span>. </p><p>Recall that in lecture slide <a href="https://ericdarve.github.io/cme216-spring-2020/Slides/AD/AD.pdf#page=39">35</a>/47 of AD.pdf, we formulate the inverse modeling problem as a PDE-constrained optimization problem</p><div>\[\begin{aligned}
\min_{a, b}\ &amp; \int_{0}^t ( u(0, t)- u_0(t))^2 dt\\ 
\mathrm{s.t.}\ &amp; \frac{\partial u(x, t)}{\partial t} = \kappa(x)\Delta u(x, t) + f(x, t), \quad t\in (0,T), x\in (0,1) \\
&amp; -\kappa(0)\frac{\partial u(0,t)}{\partial x} = 0, t&gt;0\\
&amp; u(1, t) = 0, t&gt;0\\
&amp; u(x, 0) = 0, x\in [0,1]\\
&amp; \kappa(x) = a x + b
\end{aligned}\]</div><p>We consider the discretization of the above forward problem. We divide the domain <span>$[0,1]$</span> into <span>$n$</span> equispaced intervals. We consider the time horizon <span>$T = 1$</span>, and divide the time horizon <span>$[0,T]$</span> into <span>$m$</span> equispaced intervals. We use a finite difference scheme to solve the 1D heat equation Equations (1)–(3). Specifically, we use an implicit scheme for stability:</p><div>\[\frac{u^{k+1}_i-u^k_i}{\Delta t} = \kappa_i \frac{u^{k+1}_{i+1}+u^{k+1}_{i-1}-2u^{k+1}_i}{\Delta x^2} + f_i^{k+1},\]</div><div>\[k=1,2,\ldots,m, i=1,2,\ldots, n \tag{4}\]</div><p>where <span>$\Delta t$</span> is the time interval, <span>$\Delta x$</span> is the space interval, <span>$u_i^k$</span> is the numerical approximation to <span>$u((i-1)\Delta x, (k-1)\Delta t)$</span>, <span>$\kappa_i$</span> is the numerical approximation to <span>$\kappa((i-1)\Delta x) = a + b(i-1)\Delta x$</span>, and <span>$f_i^{k} = f((i-1)\Delta x, (k-1)\Delta t)$</span>.</p><p>For the insulated boundary, we introduce the ghost node <span>$u_0^k$</span> at location <span>$x=-\Delta x$</span>, and the insulated boundary condition can be numerically discretized by </p><div>\[-\kappa_1 \frac{u_2^{k}-u_0^k}{2\Delta x} = 0\tag{5}\]</div><p>Let</p><div>\[U^k = \begin{bmatrix}u_1^k\\ u_2^k\\ \vdots\\ \\u_n^k\end{bmatrix}\]</div><p>The index starts from 1 and ends with <span>$n$</span>. Using the finite difference scheme, together with eliminating the boundary values <span>$u_0^k$</span>, <span>$u_{n+1}^k$</span>, we have the following formula</p><div>\[AU^{k+1} = U^k + F^{k+1}\]</div><ol><li>Express the matrix <span>$A\in \mathbb{R}^{n\times n}$</span> in terms of <span>$\Delta t$</span>, <span>$\Delta x$</span> and <span>$\{\kappa_i\}_{i=1}^{n}$</span>. What is <span>$F^{k+1}\in \mathbb{R}^n$</span> ?</li></ol><p>Hint: Can you eliminate <span>$u_0^k$</span> and <span>$u_{n+1}^k$</span> in Eq. (4) using Eq. (5) and <span>$u_{n+1}^k=0$</span> ?</p><p>The starter code <code>Case1D/starter1.jl</code> precomputes the force vector <span>$F^k$</span> and packs it into a matrix <span>$F\in \mathbb{R}^{(m+1)\times n}$</span>. </p><ol><li>Use <code>spdiag</code><sup class="footnote-reference"><a id="citeref-spdiag" href="#footnote-spdiag">[spdiag]</a></sup>  to construct <code>A</code> as a <code>SparseTensor</code> (see the starter code for details). <code>spdiag</code> is an ADCME function. See the documentation<sup class="footnote-reference"><a id="citeref-spdiag" href="#footnote-spdiag">[spdiag]</a></sup> for the syntax. Here <span>$\kappa$</span> is given by</li></ol><div>\[\kappa(x) = 2+1.5x\]</div><p>For debugging, check that your <span>$A_{ij}$</span> is tridiagonal. You can use <code>run(sess, A)</code> to evaluate the <code>SparseTensor</code> <code>A</code>. You should get the following values:</p><table><tr><th style="text-align: right">Entry</th><th style="text-align: right">Value</th></tr><tr><td style="text-align: right"><span>$A_{11}$</span></td><td style="text-align: right"><span>$201$</span></td></tr><tr><td style="text-align: right"><span>$A_{12}$</span></td><td style="text-align: right"><span>$-200$</span></td></tr><tr><td style="text-align: right"><span>$A_{21}$</span></td><td style="text-align: right"><span>$-101.5$</span></td></tr><tr><td style="text-align: right"><span>$A_{33}$</span></td><td style="text-align: right"><span>$207$</span></td></tr><tr><td style="text-align: right"><span>$A_{10,10}$</span></td><td style="text-align: right"><span>$228$</span></td></tr></table><p>The computational graph of the dynamical system can be efficiently constructed using <code>while_loop</code>. </p><ul><li>Implement the forward computation using <code>while_loop</code>. Turn in your code.</li></ul><p>For debugging, you can plot the temperature on the left side, i.e., <span>$u(0,t)$</span>. You should have something similar to the following plot </p><p><img src="https://github.com/ADCMEMarket/ADCMEImages/blob/master/ADCME/ex1_reference.png?raw=true" alt/></p><p>Now we are ready to perform inverse modeling. </p><ul><li>Read the starter code <code>Case1D/starter2.jl</code> carefully and complete the missing implementations. Turn in your code. What is your estimate <code>a</code> and <code>b</code>?</li></ul><h2 id="Problem-2:-Function-Inverse-Problem"><a class="docs-heading-anchor" href="#Problem-2:-Function-Inverse-Problem">Problem 2: Function Inverse Problem</a><a id="Problem-2:-Function-Inverse-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-2:-Function-Inverse-Problem" title="Permalink"></a></h2><p>Let us consider the function inverse problem, where we do not know the form of <span>$\kappa(x)$</span>. To this end, we substitute <span>$\kappa(x)$</span> using a neural network. We will use physics constrained learning (PCL) to train <span>$\kappa(x)$</span> from the temperature data <span>$u_0(x, t)$</span>, where <span>$x$</span> is the location of a sensor.</p><p>Since we do not know the form of <span>$\kappa(x)$</span>, we need more data to solve the inverse problem. Therefore, we assume that we place sensors at the first 25 locations in the discretized grid. The observation data <code>data_pcl.txt</code> is a <span>$(m+1)\times 25$</span> matrix; each column corresponds to the observation at one sensor. </p><p>In this problem, let us parametrize <span>$\kappa(x)$</span> with a fully connected neural network with 3 hidden layers, 20 neurons per layer, and <span>$\tanh$</span> activation functions. In ADCME, such a neural network can be constructed using </p><pre><code class="language-julia">y = fc(x, [20,20,20,1])</code></pre><p>Here x is a <span>$n \times 1$</span> input, y is a <span>$n \times 1$</span> output, <span>$[20,20,20,1]$</span> is the number of neurons per layer (last output layer only has 1 neuron), and fc stands for &quot;fully-connected&quot;. </p><p>Assume that the neural network is written as <span>$\kappa_\theta(x)$</span>, where <span>$\theta$</span> is the weights and biases.</p><ul><li>Write down the mathematical optimization problem for the inverse modeling. What variables are we optimizing for this problem?</li><li>Complete the starter code <code>Case1D/starter3.jl</code> for conducting physics constrained learning. The observation data is provided as <code>data_pcl.txt</code>. Run the program several times to ensure you do not terminate early at a bad local minimum. Turn in your code.</li><li>Plot your estimated <span>$\kappa_\theta$</span> curve. </li></ul><p>Hint: Your curve should look like the following</p><p><img src="./assets/kappa.png" alt/></p><ul><li>Add 1% and 10% Gaussian noise to the dataset and redo (7). Plot the estimated <span>$\kappa_\theta$</span> curve. Comment on your observations.</li></ul><p>Hint: You can add noise using</p><pre><code class="language-julia">uc = @. uc * (1 + 0.01*randn(length(uc)))
uc = @. uc * (1 + 0.1*randn(length(uc)))</code></pre><p>Here <code>@.</code> is for elementwise operations. </p><h2 id="Problem-3:-Parameter-Inverse-Problem-in-2D"><a class="docs-heading-anchor" href="#Problem-3:-Parameter-Inverse-Problem-in-2D">Problem 3: Parameter Inverse Problem in 2D</a><a id="Problem-3:-Parameter-Inverse-Problem-in-2D-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-3:-Parameter-Inverse-Problem-in-2D" title="Permalink"></a></h2><p>In this problem, we will explore more deeply how ADCME works with numerical solvers. We will use an important technique, custom operators, for incorporating C++ codes. This will be useful when you want to accelerate a performance-critical part, or you want to reuse existing codes. To make the problem simple, the <code>C++</code> kernel has been prepared for you. For this exercise, you will be working with <code>Case2D/starter.jl</code>. </p><p>We consider the 2D case and <span>$T=1 $. We assume that $\Omega=[0,1]^2$</span>. We impose zero boundary conditions on the entire boundary <span>$\Gamma_D=\partial\Omega$</span>. Additionally, we assume that the initial condition is zero everywhere. Two sensors are located at <span>$(0.2,0.2)$</span> and <span>$(0.8,0.8)$</span> and these sensors record time series of the temperature <span>$u_1(t)$</span> and <span>$u_2(t)$</span>. The thermal diffusivity coefficient is a linear function of the space coordinates</p><div>\[\kappa(x, y) = a + bx + cy\]</div><p>where <span>$a, b$</span> and <span>$c$</span> are three coefficients we want to find out from the data <span>$u_1(t)$</span> and <span>$u_2(t)$</span>. </p><ul><li>Write down the mathematical optimization problem for the inverse modeling. As before, explain what variables we are optimizing for this problem.</li></ul><p>We use the finite difference method to discretize the PDE. Consider <span>$\Omega=[0,1]\times [0,1]$</span>, we use a uniform grid and divide the domain into <span>$m\times n$</span> squares, with length <span>$\Delta  x$</span>. We also divide <span>$[0,T]$</span> into <span>$N_T$</span> intervals of equal length. The implicit scheme for the equation is </p><div>\[\frac{u_{ij}^{k+1}-u_{ij}^k}{\Delta t} = \kappa_{ij}\frac{u_{i+1,j}^{k+1}+u_{i,j+1}^{k+1}+u_{i-1,j}^{k+1}+u_{i,j-1}^{k+1}-4u_{ij}^{k+1}}{\Delta x^2} + f_{ij}^{k+1}\]</div><p>where <span>$i=2,3,\ldots, m, j=2,3,\ldots, n, k=1,2,\ldots, N_T$</span>.</p><p>Here <span>$u_{ij}^k$</span> is an approximation to <span>$u((i-1)h, (j-1)h, (k-1)\Delta t)$</span>, and <span>$f_{ij}^k = f((i-1)h, (j-1)h, (k-1)\Delta t)$</span>.</p><p>We flatten <span>$\{u_{ij}^k\}$</span> to a 1D vector <span>$U^k$</span>, using <span>$i$</span> as the leading dimension, i.e., the ordering of the vector is <span>$u_{11}^k, u_{12}^k, \ldots$</span>; We also flatten <span>$f_{ij}^{k+1}$</span> and <span>$\kappa_{ij}$</span> as well. </p><p>In this problem, we extend the AD framework using custom operators (also known as <em>external function support</em> in the AD community). In the starter code <code>Case2D/starter.jl</code>, we provide a function, <code>heat_equation</code>, a differentiable heat equation solver, which is already implemented for you using C++. By using custom operators, we replace the PDE solver node in the computational graph with our own, more efficient, implementation. </p><p>Read the <a href="ADCME_setup.md">instructions</a> on how to compile the custom operator, and answer the following two questions. </p><ul><li>Similar to Problem 1, implement the forward computation using <code>while_loop</code> with the starter code <code>Case2D/starter.jl</code>. Plot the curve of the temperature at <span>$(0.5,0.5)$</span>. </li></ul><p>Hint: you should obtain something similar to</p><p><img src="https://github.com/ADCMEMarket/ADCMEImages/blob/master/ADCME/ex2_reference.png?raw=true" alt/></p><p>The parameters used in this problem are: <span>$m=50$</span>, <span>$n=50$</span>, <span>$T=1$</span>, <span>$N_T=50$</span>, <span>$f(\mathbf{x},t) = e^{-t}\exp(-50((x-0.5)^2+(y-0.5)^2))$</span>, <span>$a = 1.5$</span>, <span>$b=1.0$</span>, <span>$c=2.0$</span>. </p><p>The data file <code>data.txt</code> is a <span>$(N_T+1)\times 2$</span> matrix, where the first and the second columns are <span>$u_1(t)$</span> and <span>$u_2(t)$</span> respectively. </p><ul><li>Use these data to do inverse modeling and report the values <span>$a, b$</span> and <span>$c$</span>. We do not provide a starter code intentionally, but the forward computation codes in <code>Case2D/starter.jl</code> and neural-network-based inverse modeling codes in <code>Case1D/starter3.jl</code> will be helpful. </li></ul><p>Hint: </p><ul><li>For checking your program, you can save your own <code>data.txt</code> from Question 10, try to estimate <span>$a$</span>, <span>$b$</span>, and <span>$c$</span>, and check if you can recover the true values. </li><li>If the optimization stops too early, you can multiply your loss function by a large number (e.g., <span>$10^{10}$</span>) and run your <code>BFGS!</code> optimizer again. An alternative approach is to use a smaller tolerance. See the <code>BFGS!</code> function documentation for details. </li></ul><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-spdiag"><a class="tag is-link" href="#citeref-spdiag">spdiag</a><a href="https://kailaix.github.io/ADCME.jl/dev/api/#ADCME.spdiag-Tuple{Integer,Vararg{Pair,N}%20where%20N}">API Reference</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tu_debug/">« Advanced: Debugging and Profiling</a><a class="docs-footer-nextpage" href="../newton_raphson/">Newton Raphson »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 24 October 2020 20:27">Saturday 24 October 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
